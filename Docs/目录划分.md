为了实现逻辑与表现的分离，并让 Claude Code 能够精准地在“规则定义区”和“渲染实现区”之间切换，我们需要一套严谨的 **程序集（Assembly）驱动型目录结构**。

在 Unity 中，物理上的文件夹隔离只是表象，真正的隔离墙是 **`.asmdef` (Assembly Definition)** 文件。

---

## 1. 推荐目录结构：三层架构

建议将所有代码放在 `Assets/_Project/` 目录下，分为 `Framework`（底层框架）和 `Game`（业务逻辑）两个主轴。

```text
Assets/
├── _Project/
│   ├── Framework/ (框架层：通用的、不随游戏改变的工具)
│   │   ├── Core/ (基础接口、单例、逻辑步进引擎)
│   │   ├── AIBridge/ (状态导出 JSON、Command 自动注册)
│   │   ├── DI/ (VContainer 的扩展封装)
│   │   └── Framework.asmdef (不引用 UnityEngine 的核心部分)
│   │
│   ├── Game/ (业务层：具体的游戏逻辑)
│   │   ├── Domain/ (核心逻辑层：纯 C#，TDD 战场)
│   │   │   ├── Models/ (POCO 数据类)
│   │   │   ├── Systems/ (战斗计算、任务逻辑)
│   │   │   └── Game.Domain.asmdef (绝对禁绝 UnityEngine)
│   │   │
│   │   ├── Presentation/ (表现层：Unity 专场)
│   │   │   ├── Views/ (MonoBehaviour, UI, 特效控制)
│   │   │   ├── ViewModels/ (数据转换层)
│   │   │   └── Game.Presentation.asmdef (引用 Domain 和 UnityEngine)
│   │   │
│   │   └── Infrastructure/ (基础设施：实现 Domain 的物理/存档接口)
│   │       └── Game.Infrastructure.asmdef
│   │
│   └── Tests/ (测试层)
│       ├── Editor/ (针对 Domain 的纯 C# 单元测试)
│       └── Runtime/ (针对 Unity 集成的测试)

```

---

## 2. 核心隔离策略：ASMDEF 依赖链

这是防止 AI 或你不小心在逻辑层写下 `GameObject.Find` 的关键：

1. **`Game.Domain.asmdef`**:
* **不要勾选** "Use UI Modules" 或任何 Unity 内置引用。
* 它只能引用 `Framework.asmdef`（纯 C# 部分）。
* **意义**：这是游戏的“法律文本”，Claude 在这里写代码时，其行为完全可预测，不依赖 Unity 场景。


2. **`Game.Presentation.asmdef`**:
* 引用 `Game.Domain` 和 `Framework`。
* 可以引用 `UnityEngine`。
* **意义**：这是游戏的“翻译官”，负责把 Domain 里的 HP 变化翻译成血条的缩放。


3. **`Framework.asmdef`**:
* 这里定义 `IPhysicsService` 接口，但不实现它。



---

## 3. 为什么这样组织对 AI 极其友好？

* **减少 Context 污染**：当你让 Claude 修复一个伤害计算 Bug 时，你可以明确告诉它：“只看 `Game/Domain` 目录”。它不会被成堆的 `MonoBehaviour` 生命周期干扰。
* **测试精准打击**：Claude 可以独立运行 `Game/Domain` 对应的测试集。如果测试通过但 Unity 里表现不对，它能立刻判断出是 `Presentation` 层的绑定问题，而不是逻辑算错了。
* **Schema 自动感知**：你可以让 Claude 扫描 `Game/Domain/Models` 目录，它能瞬间生成整张游戏的数据全景图。

---

## 4. 框架 vs 业务的代码边界 (示例)

| 功能 | 归属 | 理由 |
| --- | --- | --- |
| `Command` 基类 | **Framework** | 所有游戏都要用命令模式 |
| `MoveCommand` 实现 | **Game.Domain** | 移动速度、碰撞阻挡是业务逻辑 |
| JSON 序列化工具 | **Framework** | 底层技术实现 |
| `PlayerState` 类 | **Game.Domain** | 玩家属性是业务核心 |
| `VContainer` 绑定 | **Game.Infrastructure** | 决定哪个逻辑对应哪个表现 |

---

## 5. 进阶建议：使用 UPM (Unity Package Manager) 模式

如果你希望更进一步，可以把 `Framework` 移出 `Assets` 目录，放到与 `Assets` 同级的 `Packages/com.yourname.framework/` 中。

* **优点**：框架代码在 Editor 里会被保护起来，Claude 默认不会去修改它，从而把精力集中在 `Assets/Game/` 里的业务代码。
* **IL2CPP 友好**：你可以在 Package 里统一处理 AOT 的 `link.xml`。

**下一步建议：**
我们需要为这个结构生成具体的 `.asmdef` 配置文件内容，还是先写一个 `Game.Domain` 层的 `PlayerState` 和对应的测试用例来演示隔离效果？