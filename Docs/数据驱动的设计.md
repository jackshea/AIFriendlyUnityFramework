在“AI 原生”框架中，**数据驱动设计 (Data-Driven Design)** 不仅仅是将数值填入 Excel，更核心的哲学是：**“逻辑是引擎，数据是燃料，而数据结构（Schema）是 AI 的地图。”**

在这种设计下，你不再是写死一个 `if (lvl == 2)`，而是通过配置数据来定义行为。以下是针对你框架需求的数据驱动深度补充：

---

### 1. 静态配置 vs. 运行时状态 (Static Config vs. Runtime State)

要让 Claude 完美理解游戏，必须严谨区分两类数据：

* **配置数据 (Config Data):** 游戏规则、怪物数值、技能效果。这些是只读的，通常存在 JSON/Excel 中。
* **状态数据 (Runtime State/Data Store):** 玩家当前的 HP、位置、背包物品。这些是可变的，存在 `Domain` 层的 POCO 类中。

**AI 友好做法：**
将 Unity 的 `ScriptableObject` (SO) 视为编辑工具，但在进入逻辑层前，必须将其**序列化为纯 C# 的 POCO 类**。Claude 不应该直接操作 SO，因为它无法在单元测试环境（非 Unity 环境）中轻松实例化 SO。

---

### 2. 基于 Schema 的状态树 (The State Tree)

不要让状态散落在各个角落。建立一个全局唯一的 **Root State**。

```csharp
// Game.Domain.Models
public class GameState {
    public PlayerState Player { get; } = new();
    public WorldState World { get; } = new();
    public InventoryState Inventory { get; } = new();
}

```

**对 AI 的好处：**
当 Claude 需要诊断问题时，它只需要执行一条指令 `DumpState`，框架就会递归地将整个 `GameState` 导出为 JSON。Claude 看到的是一棵完整的、有层次的逻辑树，而不是碎片的变量。

---

### 3. 数据驱动的“逻辑响应” (Reactive Binding)

在数据驱动设计中，逻辑层只修改数据，不调用表现层。我们使用 **ReactiveProperty** 来实现数据变化对表现层的驱动。

* **逻辑层 (Domain):** `playerState.HP.Value -= 10;`
* **表现层 (View):** 监听 `HP` 变化，触发血条动画。

**这种设计的 TDD 优势：**
Claude 写测试时，只需要断言（Assert）`HP.Value` 是否等于 90。它完全不需要关心 UI 到底有没有变红。这使得测试可以在毫秒级完成。

---

### 4. 数据与指令的闭环：Data-Driven Commands

让指令（Command）也变成数据驱动。
例如，一个技能释放不仅仅是一个函数，而是一个**配置好的数据对象**。

```json
{
  "commandType": "CastSkill",
  "skillId": 1001,
  "payload": {
    "targetId": "mob_05",
    "damageMultiplier": 1.5
  }
}

```

**AI 协作工作流：**

1. **AI 读取配置：** Claude 读取 `Skills.json`，发现技能 1001 的冷却时间是 5 秒。
2. **AI 检查状态：** Claude 读取 `RuntimeState`，发现上次释放时间是 3 秒前。
3. **AI 判断逻辑：** Claude 告诉用户（或直接执行测试）：“指令无效，技能还在冷却中”。

---

### 5. 针对 IL2CPP 的数据序列化方案

由于 IL2CPP 严格限制运行时反射，数据驱动框架需要注意以下技术点：

* **避免 AOT 泛型问题：** 尽量不要在数据类中使用复杂的嵌套泛型（如 `Dictionary<List<T>, Dictionary<K, V>>`）。
* **Source Generators：** 强烈建议使用 C# 源生成器（Source Generators）在编译阶段生成序列化代码（如使用 `System.Text.Json` 的 AOT 模式或 `MemoryPack`）。
* **VContainer 注册：** 所有的 POCO 数据类都应该通过 VContainer 注册为单例或作用域对象。

---

### 6. 开发范式建议：Schema-First

1. **定义 Schema：** 你和 Claude 先商量好 JSON 或 C# Data Class 的结构。
2. **生成数据：** Claude 生成一份测试用的伪数据（Mock Data）。
3. **注入逻辑：** 将数据注入到 `Domain` 系统中运行测试。
4. **映射 Unity：** 最后去 Unity 里建立从这个数据结构到 Prefab 的映射。

**总结：**
数据驱动让你的游戏变成了一个**“可以被 JSON 描述的数学模型”**。对于 Claude Code 来说，处理 JSON 的能力远强于理解复杂的 C# 回调逻辑。

---

**下一步建议：**
你想看一看如何编写一个**自动将整个数据中心序列化并暴露给 Claude** 的 `StateWatcher` 工具代码吗？