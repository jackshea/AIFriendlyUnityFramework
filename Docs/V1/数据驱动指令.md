在 AI 原生框架中，**“数据驱动指令” (Data-Driven Commands)** 的核心思想是：**将“玩家的意图”与“逻辑的执行”彻底解耦**。

指令不再是一个不可见的函数调用，而是一个**可以被截获、被序列化、被 AI 阅读、甚至被延迟执行的“数据包”**。

---

### 1. 指令的结构：从函数到 POCO

在传统开发中，你可能调用 `player.CastSkill(101)`。在 ALF 框架中，这被拆解为一个数据对象：

```csharp
// Game.Domain.Commands
[Serializable]
public class CastSkillCommand : ICommand {
    [Description("技能配置ID")]
    public int SkillId { get; set; }

    [Description("施法目标实例ID")]
    public string TargetId { get; set; }

    [Description("施法时的坐标")]
    public Vector3Data Position { get; set; }

    // 并不在 Command 里写逻辑，它只是个“需求描述”
}

```

**为什么这对 AI 友好？**
Claude Code 不需要去理解复杂的函数调用栈。它只需要生成一段 JSON：
`{ "type": "CastSkillCommand", "SkillId": 101, "TargetId": "mob_7" }`
发送给你的框架，游戏逻辑就会运行。这就像是给游戏提供了一个 **REST API**。

---

### 2. 指令处理器：逻辑的守门人 (Command Handlers)

指令本身不包含逻辑，逻辑存在于 `CommandHandler` 中。

* **验证层 (Validator):** 在执行前，检查数据。例如：蓝量够吗？目标在射程内吗？
* **执行层 (Executor):** 真正修改 `DataStore` 的数值。

```csharp
public class CastSkillHandler : ICommandHandler<CastSkillCommand> {
    public void Handle(GameState state, CastSkillCommand cmd) {
        // 1. 从静态数据中心获取技能数值
        var skillData = state.StaticConfig.GetSkill(cmd.SkillId);
        
        // 2. 修改运行时状态
        state.Player.MP.Value -= skillData.Cost;
        state.World.GetEntity(cmd.TargetId).HP.Value -= skillData.Damage;
        
        // 3. 记录日志（供 AI 回溯）
        state.CommandHistory.Add(cmd);
    }
}

```

---

### 3. 指令清单 (The Command Manifest)

为了让 Claude 知道它能做什么，框架需要自动生成一份**“指令说明书”**。

1. **扫描:** 框架扫描所有实现 `ICommand` 的类。
2. **生成:** 生成一份 JSON 格式的清单，描述每个指令需要的参数。
3. **喂给 AI:** Claude 读了清单，就学会了如何控制你的游戏。

> **Claude 的思考过程：**
> “玩家血量低了，我查了一下清单，有一个 `UseItemCommand`。它需要 `ItemId`。我查了一下背包数据，`Item_01` 是血瓶。好，我构造一个 `UseItemCommand { ItemId: "Item_01" }` 发给框架。”

---

### 4. 闭环流：AI 如何利用这个设计进行调试

由于指令是数据，我们可以实现**“时光倒流”**：

1. **Bug 发生:** 玩家在 Tick 500 莫名其妙死掉了。
2. **AI 介入:** Claude 请求 `GetCommandHistory`。
3. **发现异常:** Claude 看到在 Tick 499 发生了一个 `ApplyDamageCommand { Amount: 999999 }`。
4. **定位根源:** Claude 追踪这个 Command 是谁发出的，发现是某个技能计算公式在特定边界条件下溢出了。
5. **修复与验证:** Claude 修改逻辑层代码，然后**重新发送**历史指令流。如果这次 Tick 500 玩家没死，Bug 修复确认。

---

### 5. 针对 IL2CPP 的优化策略

在 IL2CPP 下，由于不能动态生成代码，我们需要注意：

* **显式注册:** 不要依赖反射来寻找 Handler。使用 VContainer 在 `LifetimeScope` 中显式注册：
`builder.Register<ICommandHandler<CastSkillCommand>, CastSkillHandler>(Lifetime.Singleton);`
* **AOT 泛型:** 如果你使用 `CommandDispatcher<T>`，确保在代码中至少有一处显式调用过该泛型版本，防止 IL2CPP 在裁剪时将其剔除。

---

### 总结：数据驱动指令的价值

| 维度 | 传统函数调用 | 数据驱动指令 |
| --- | --- | --- |
| **可观测性** | 瞬时发生，难以记录 | 永久留存，可序列化 |
| **AI 交互** | 需要 AI 编写脚本并编译 | AI 仅需发送 JSON 数据包 |
| **测试便利性** | 需要复杂的 Mock 注入 | 只需要验证 Command 执行后的 State 变化 |
| **网络同步** | 难（需要处理 RPC） | 易（天然支持序列化同步） |

**下一步建议：**
既然我们明确了指令和数据的结构，你想让我为你写一个基础的 `CommandDispatcher` 和 `ICommand` 的**纯 C# 参考实现**吗？这将是你 `Game.Domain` 程序集的基石。